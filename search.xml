<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[三阶魔方还原快速上手]]></title>
    <url>%2Fblog%2Frestore-magic-cube-quick-start%2F</url>
    <content type="text"><![CDATA[其实还原一个三阶魔方，如果不追求速度的话，是很容易的，一共分为 步，后半部分需要记 个公式，能熟练记住的话可以稳定在 1 分钟以内 前言首先需要理解三阶魔方（之后简称魔方）的构造原理，它由四部分构成，是不可能互相变化的： 中心轴 中心块： 直接连接在轴上，每个的位置是固定、不可变、不可操作的 棱块： 共 4 * 6 / 2 = 12 个，每个有两个带有颜色的面 角块：共 4 * 6 / 3 = 8 个，每个有三个带有颜色的面 后面的公式会包含以下几种操作： 顺时针旋转90度 逆时针旋转90度 左侧面 L L’ 右侧面 R R’ 正面 F F’ 背面 B B’ 顶面 U U’ 底面 D D’ 面向该面，顺时针 / 逆时针旋转90度 若有数字，表示连续几次 若有括号，表示建议将括号内的操作连起来，顺手 若为小些，表示一起旋转前两层 刚才说了，中心块是固定不可变的，也就意味着颜色的顺序也是固定的，我们一般会逐层还原，从白色面还原到黄色面（即白色面为底层，黄色面为顶层） 求哪位设计小姐姐帮忙画个配图…… Step1 底层十字架目标： 白色面四个棱块归位，并保证其每个面的颜色和它所在面的中心块颜色一致 方法：略（不需要公式，自己想就好） Step2 底层角块还原目标：白色面四个角块归位，并保证其每个面的颜色和它所在面的中心块颜色一致（没有正确的配图…想象一下，图中顶层有颜色的这块应该在底层，左侧面蓝色、右侧面红色、底面白色） 方法：略（不需要公式，自己想就好） Step3 中层棱块还原目标：中间层的四个棱块归位，并保证其每个面的颜色和它所在面的中心块颜色一致 场景一：公式3 - 1 (面向左前面) (R&#39; U&#39;) (R&#39; U&#39;) (R&#39; U R U) 场景二：公式3 - 2 (面向左后面) (R U) (R U) (R U&#39; R&#39; U&#39;) R&#39; 场景三：公式3 - 1 + 公式3 - 2 Step4 顶面十字架目标：顶面的四个棱块归位，保证其顶面的颜色和顶面中心块颜色一致 场景一：公式4 - 1 (面向左前面) F (R U R&#39; U&#39;) F&#39; 场景二：公式4 - 2 (面向右后面) f (R U R&#39; U&#39;) f&#39; 场景三：公式4 - 1 + 公式4 - 2 Step5 顶面角块归位目标：顶面的四个角块归位，保证其顶面的颜色和顶面中心块颜色一致 公式5 - 1 (R&#39; U2) (R U) (R&#39; U R) 以下场景均可用若干次公式5 - 1完成还原 Step6 顶层角块还原目标：顶层的四个角块归位，保证其每个面的颜色和它所在面的中心块颜色一致 公式6 - 1：将右上、左下、右下三个角块逆时针旋转 (面向顶面) (R U&#39; R) B2 (R&#39; U R) B2 R2 Step7 顶层棱块还原目标：顶层的四个棱块归位，保证其每个面的颜色和它所在面的中心块颜色一致 公式6 - 2：将左中、下中、右中三个棱块逆时针旋转 (面向正面) R U&#39; (R U) (R U) (R U&#39; R&#39; U&#39;) R2]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Life</tag>
        <tag>Magic-Cube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在Android中使用Java8语法特性]]></title>
    <url>%2Fblog%2Fuse-java8-features-in-android%2F</url>
    <content type="text"><![CDATA[做了三个月 Flutter 开发后，逐渐喜欢上了 Dart 语言，在回归到主项目后惊喜的发现也可以使用多数 Java8 语法了，因此研究了下原理～ Android and JavaJava 在 Android 的快速发展中扮演着非常重要的角色，开发语言是 Java，Framework 框架（即 Android SDK），引用了 80% 的 JDK-API，开发工具 Android Studio 是基于 Java 开发工具 IDEA 二次开发完成的，这些和 Java 都有着千丝万缕的关系 但是可能是受到与 Oracle 公司法律诉讼的影响，Google 在 Android 上针对 Java 的升级一直都不是很积极 Java7 （2011.07） Android 从1.0 一直升级到4.4，迭代了将近19个Android版本，才在4.4版本中支持了Java 7 Java8 （2014.03） RetraLambda 插件 然后从 Android 4.4 版本开始算起，一直到 Android N(7.0) 共4个 Android 版本，才在 Jack/Jill 工具链勉强支持了Java 8。但由于 Jack/Jill 工具链在构建流程中舍弃了原有 Java 字节码的体系，导致大量既有的技术沉淀无法应用，致使许多 App 工程放弃了接入 最后直到 Android P(9.0) 版本， Google 才在 Android Studio 3.x 中通过新增的 D8 dex 编译器正式支持了 Java 8，但部分 API 并不能全版本支持 Java8 new features overviewJava8 是 Java 非常重要的一个版本，从这个版本开始，Java 开启支持函数式编程。也吸收了运行在JVM上的 Groovy、Scala 这种动态脚本语言的特性后，Java8 在语言的表达力、简洁性优良很大的提高 Java8 的主要语言特性改进概括起来包括以下几点： Lambda expression - Lambda 表达式 Method reference - 方法直接引用，也就是函数式接口 Default method - 抽象接口中允许使用 default 关键字，来定义非抽象方法 Repeating annotation - 可重复使用注解 Stream API - 通过流式调用支持 map、filter 等高阶函数 Date API - 改进、扩展了的关于日期和时间的 API New tools - 新的工具，比如分析器、引擎（Nashorn 引擎 jjs、 类依赖分析器 jdeps） Optional - 用来解决空指针异常的 Optional 类 Nashorn, JavaScript Engine - 增加了一个 JS 引擎，允许在 JVM 上运行特定的 js 程序 接下来我们看一下 Java8 语法特性是如何在 JVM 上工作的，以 Lambda 表达式为例 Lambda expressionLambda 表达式主要用来定义行内执行的方法类型接口，如一个简单的函数式接口，它免去了使用匿名方法的麻烦，并且给予 Java 简单但是强大的函数化编程能力，语法如下： (parameters) -&gt; expression (parameters) -&gt; {statements;} 函数式接口：Java8 对一类特殊类型接口的称呼，这类接口只定义了除了 Object 对象公共方法外的唯一的抽象方法的接口 为什么定义此接口？不想为 Lambda 表达式单独定义一种特殊的函数类型，比如箭头类型，想采用 Java 现有的类型系统，避免增加一个结构化函数类型来增加复杂性 比如我们写了这样的一个包含 Lambda 表达式的 demo： 1234567public class HelloLambda &#123; public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println("hello")).start(); &#125;&#125; 使用 javac HelloLambda.java 命令编译，结果如下 可以看到还是有箭头符号的，使用 javap -c -p HelloLambda 命令进行反汇编，结果如下 可以看到其中有一条 invokedynamic 调用方法指令，我们知道 JVM 中调用方法一共有五种指令，其余四种为： invokestatic - 调用静态方法 invokespecial - 调用私有方法、父类方法、类构造器方法 invokeinterface - 调用接口方法 invokevirtual - 调用需方法（除了以上以外的方法） 这四种指令，都是在变异期间生成的 class 文件中，通过常量池 Constant Pool 的 MethodRef 常量已经固定了目标方法的符号信息（方法所属者及其类型、方法名字、参数顺序和类型、返回值），虚拟机使用符号信息能直接解释出具体的方法，直接调用 invokedynamic - 动态执行方法 那么，invokedynamic 是如何通过引导方法找到所属者及其类型的呢？ 使用 javap -v HelloLambda.class 查看本地变量表，结果如下 对应到了常量池中这一条数据，注意常量池中的 InvokeDynamic 不是指令，代表的是 Constant InvokeDynamic Info结构，后面紧跟的 #0 标识的是 BootstrapMethod 区域中引导方法的索引： 可以发现引导方法中的 java/lang/invoke/LambdaMetafactory.metafactory，才是 invokedynamic 指令执行过程中的关键步骤，源码如下： 可以发现，执行该方法，会在内存中动态生成一个实现 Lambda 表达式对应函数式接口的实例类型，并在接口的实现方法中调用新增的静态私有方法 运行 java -Djdk.internal.lambda.dumpProxyClasses HelloLambda.class，将内存中动态生成的类型输出到本地（⚠️ 需要在项目根目录 src 下执行此命令） 运行 javap -p -c HelloLambda\$\$Lambda\$1 反编译，可以看到生成累的实现为 在 run 方法中使用了 invokestatic 指令，直接调用了 HelloLambda.lambda\$main\$0 这个在编译期间生成的静态私有方法 至此，以上就是 Lambda 表达式在 Java 底层的实现原理，那么在 Android 中，是如何处理的呢？ Run directly on Android?Java Bytecode, JVM 字节码，是不能直接运行在 Android 系统上的，需要转换成 Android Bytecode，也就是 Dalvik / ART 字节码 Android support indirectly因此 Android 进行了间接支持，在 Java 字节码转换到 Android 字节码的过程中增加一个步骤，把字节换转换为 Android 虚拟机支持的字节码，这个过程可以称为 脱糖 (Desugar) 无论是之前的 Jack &amp; Jill 工具，还是现在的 D8 dex 编译器，处理方式都是类似的：在流程上，增加脱糖的过程；在原理上，参考 Lambda 在 Java 底层的实现，把这些实现移植到插件或编译器工具中 Android 中支持的 Java8 语法包括： Lambda expression Method references Default method Repeating annotation 在 D8 编译方式中，脱糖的过程放在了其内部，由 Android Studio 来实现这个转换，本质上也是参考 java/lang/invoke/LambdaMetafactory.metafactory 的方式将原本在运行时生成在内存中的类，在 D8 编译 dex 期间，直接生成并写入到 dex 文件中 实际开发中，保证 Android Studio 版本在 3.0 及以上，在 module 的 build.gradle 文件，在android 节点中增加如下代码后，该 module 即可完成对部分 Java8 语法特性的支持 1234compileOptions &#123; sourceCompatibility JavaVersion.VERSION_1_8 targetCompatibility JavaVersion.VERSION_1_8&#125; 参考： Google 官方指导文档]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac升级踩坑记录]]></title>
    <url>%2Fblog%2Fmac-reset-system-note%2F</url>
    <content type="text"><![CDATA[作为一个 IT 行业从业者，在新系统刚发布的时候当然忍不住第一时间更新，今年也是第一时间更新了 macOS Catalina (10.15) 系统，然而踩了坑，不但很多软件用不了，而且还一直在切焦点，无法正常使用，咋整？？？ 作为一个 IT 行业从业者，在新系统刚发布的时候当然忍不住第一时间更新，今年也是第一时间更新了 macOS Catalina (10.15) 系统，然而踩了坑，不但很多软件用不了，而且还一直在切焦点，无法正常使用，咋整？？？ 还好给自己留了一手，只升级了笔记本的系统，没有升级办公 Mac mini 的系统，还有的参考 想了三种方案： 笔记本恢复出厂设置 下载一个旧版本系统装到笔记本上 将 Mac mini 使用 Time Machine 进行备份，然后把备份应用到笔记本 出于安全和方便的考虑，选择了第三种方案（使用 Time Machine），因为两台电脑的一些配置不同，在应用完成后还需要进行一些设置，操作实录如下 1. 使用 Time Machine 恢复备份https://support.apple.com/zh-cn/HT203981 2. 修改用户名System Preference -&gt; Users &amp; Groups -&gt; Advanced Options -&gt; Full name 3. 修改主机名 (Terminal)1sudo scutil --set HOST liuxia 4. 修改设备名System Preference -&gt; Sharing -&gt; Computer Name 5. 修改根目录重命名根文件夹、System Preference -&gt; Users &amp; Groups -&gt; Home directory]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA AS中大大提升效率的快捷键]]></title>
    <url>%2Fblog%2Fidea-as-shortcuts%2F</url>
    <content type="text"><![CDATA[开发过程中灵活使用编译器快捷键可以大大增加开发效率 动图过段时间补 查找类 Command + O 查找文件 Command + Shift + O 查看当前类的成员Command + F12 打开命令行工具 Option + F12 立刻换行Command + Shift + Return Git Pull Command + T Git Commit Command + K Generate CodeControl + Return / Command + N Implement MethodsControl + I Override MethodsControl + O 参数提示 Command + P 自动提取方法 Command + Alt + M 自动提取参数 Command + Alt + P 自动生成变量 Command + Alt + V 包裹代码 Command + Alt + T 方法调用层级 Command + Option + H 类的层次结构 Control + H 变量高亮 Command + Shift + F7 跳转到父类 Command + U]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>AS</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keynote使用笔记]]></title>
    <url>%2Fblog%2Fnote-keynote%2F</url>
    <content type="text"><![CDATA[以前 Keynote 用的比较少，现在把使用过程中遇到的问题记录下来 在演示期间显示鼠标按下 c 键 粘贴高亮代码块首先安装 highlight 工具 1brew install highlight 先复制代码，接着执行如下代码，最后直接在 Keynote 中 Command + V 粘贴 12# Dart语言、显示行号、字号23pbpaste | highlight --syntax=dart --style=github --line-numbers --font=Monaco --font-size=23 -u "utf-8" --replace-tabs=4 --out-format=rtf --line-number-length=2 | pbcopy]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
        <tag>Keynote</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登录模块的一种设计与实现]]></title>
    <url>%2Fblog%2Fdesign-for-login-module%2F</url>
    <content type="text"><![CDATA[最近在使用 Flutter 做一个新产品，其中一个需求是完成登录模块 开发过程中遇到了临时整体变更方案的问题，由自己请求接口变为接入公司内通用 SDK，因为这部分代码设计的还算不错，没有影响实际项目进展，可见良好的设计是非常重要的 不过还是应该批判这种临时改方案、开发兜时间的行为！ 需求内容 完成登录模块，涉及到以下三端： 用户 - APP URS (User Register Service) - 帐号注册后台 客户端用户信息后台 登录业务有以下四种场景： 手机号验证码登录 第三方登录（需强制绑定手机号） 设置页内绑定第三方账号 普通打开APP 这四种场景内部的业务逻辑为： 手机号：获取验证码 -&gt; 校验验证码 -&gt; 获取个人信息 -&gt; 登录成功 三方：第三方登录 -&gt; 获取账号绑定状态 -&gt; 获取验证码 -&gt; 校验验证码 -&gt; 绑定账号 -&gt; 获取个人信息 -&gt; 登录成功 绑定三方：第三方登录 -&gt; 账号绑定 -&gt; 获取个人信息 -&gt; 登录成功 打开APP：获取个人信息 -&gt; 登录成功 以三方登录为例，时序图如下： 方案设计可以发现，登录这部分的业务场景，都是链式结构，多数比较长，而且其中有一些步骤是相似的，适合复用，因此实现方案应当完成如下的要求： 良好的模块化 - LoginTask，便于复用 支持链式定义 - LoginStream，整体记录日志与异常情况管理 对外只暴露已经定义好的登录事件链，提供可选的入参即可 如此设计后，整体的时序图为： 代码实现 抽象单个模块的行为，ILoginTask，各个小模块实现该接口 定义单个模块的生命周期回调，ILoginTaskCallback，管理类LoginStreamLine实现该接口整体管理 对外只暴露事件流的定义LoginStreamDefine如下：]]></content>
      <categories>
        <category>Project</category>
      </categories>
      <tags>
        <tag>Login</tag>
        <tag>Project Structure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flutter实现弹幕热力图]]></title>
    <url>%2Fblog%2Fflutter-heatline-view%2F</url>
    <content type="text"><![CDATA[产品提了个需求：播放器中增加弹幕热力图 问视觉小哥：曲线是怎么画出来的 视觉：用手画出来的 好像也没说错？是我高估了他的脚吗 最近 Flutter 使用得比之前熟练了一些，接了一个看起来比较有意思的需求： 一. 需求内容在播放器中增加弹幕热力图组件 （在进度条上方绘制一条根据对应时间弹幕数量多少的有颜色曲线，并将其与进度条区域填充，已播放区域的颜色为激活态颜色） 二. 方案设计前期的讨论与数据处理方式就不赘述了，结果是拿到最多50段时间对应的弹幕数，我们将其定义为关键点，也就说目前已经拿到了最多50个关键点的坐标，接下来说重点部分，也就是热力图的绘制，一开始想了三种实现方式： 引入第三方库 将曲线拆解到点的级别，每两个点连线 自定义View （CustomPaint） 关于引入第三方库的方式 发现了一个 flutter_chart 这个开源库，支持这样的现实效果， 接入过程中发现该库是针对静态图表设计的，进度动态变化的需求无法完成，且该库不支持曲线 该库功能庞大，引入会有很多无用代码 关于拆解到点级别的方式 将曲线拆解为像素，这样就都是直线 绘制曲线上每个像素点到底部进度条对应点的线即可 因为这种方式也有很明显的弊端：对性能开销较大，因此选用自定义 View 的方式 三. 实现过程 Flutter也支持自定义 View，是通过 CustomPaint + 自定义画笔 Painter 来实现的（目前这类资料较少，这也是一开始考虑使用谷歌提供图表库的原因之一） 曲线通过关键点 + 三阶贝塞尔曲线、使用类似于差值器的思想完成 进度由播放器统一控制（即播放器控制进度条与热力图各自的进度） 0. 效果图这里就不列出视觉稿了，实现效果如下，大概也就能理解需求是什么了吧 1. 曲线的绘制我们知道贝塞尔曲线是一种比较优雅的曲线，这里为了节省时间，不和视觉小哥解释，直接使用三阶贝塞尔曲线 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/// 三阶贝塞尔曲线class CubicBezierMonet &#123; static Path _point(Path path, double x0, double y0, double x1, double y1, double t0, double t1) &#123; double dx = (x1 - x0) / 3 ?? 0; path.cubicTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1); return path; &#125; static Path addCurve(Path path, List&lt;Point&gt; points, &#123;bool reversed = false&#125;) &#123; var targetPoints = List&lt;Point&gt;(); targetPoints.addAll(points); targetPoints.add(Point( points[points.length - 1].x * 2, points[points.length - 1].y * 2)); double x0, y0, x1, y1, t0; if (path == null) &#123; path = Path(); &#125; List&lt;List&lt;double&gt;&gt; arr = []; for (int i = 0; i &lt; targetPoints.length; i++) &#123; double t1; double x = targetPoints[i].x.toDouble(); double y = targetPoints[i].y.toDouble(); if (x == x1 &amp;&amp; y == y1) continue; switch (i) &#123; case 0: break; case 1: break; case 2: t1 = _slope3(x0, y0, x1, y1, x, y); arr.add([x0, y0, x1, y1, _slope2(x0, y0, x1, y1, t1), t1]); break; default: t1 = _slope3(x0, y0, x1, y1, x, y); arr.add([x0, y0, x1, y1, t0, t1]); &#125; x0 = x1; y0 = y1; x1 = x; y1 = y; t0 = t1; &#125; if (reversed) &#123; arr.reversed.forEach((f) &#123; _point(path, f[2], f[3], f[0], f[1], f[5], f[4]); &#125;); &#125; else &#123; arr.forEach((f) &#123; _point(path, f[0], f[1], f[2], f[3], f[4], f[5]); &#125;); &#125; return path; &#125; static num _sign(num x) &#123; return x &lt; 0 ? -1 : 1; &#125; // Calculate a one-sided slope. static double _slope2(double x0, double y0, double x1, double y1, double t) &#123; var h = x1 - x0; return h != 0 ? (3 * (y1 - y0) / h - t) / 2 : t; &#125; static double _slope3( double x0, double y0, double x1, double y1, double x2, double y2) &#123; double h0 = x1 - x0; double h1 = x2 - x1; double s0 = (y1 - y0) / (h0 != 0 ? h0 : (h1 &lt; 0 ? -double.infinity : double.infinity)); double s1 = (y2 - y1) / (h1 != 0 ? h1 : (h0 &lt; 0 ? -double.infinity : double.infinity)); double p = (s0 * h1 + s1 * h0) / (h0 + h1); var source = [s0.abs(), s1.abs(), 0.5 * p.abs()]; source.sort(); return (_sign(s0) + _sign(s1)) * source.first ?? 0; &#125;&#125; 2. 区域的填充这里踩了个坑，一开始想的比较简单，想直接设置好路径、画笔将路径内区域填充，但是发现对于不规则形状的支持很差 然后再一次证明了“厕所是产生灵感的地方”，去了趟 wc 后突然想到可以直接将画布裁切、路径依旧设置为一个比画布区域大的规则图形、直接将其填充绘制，这样真实效果就会是将画布和路径的交集区域填充上颜色 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class HeatLineMonet &#123; Path _path; /// 画线 HeatLineMonet paintLine(PaintConfig config, Canvas canvas, List&lt;Point&gt; points, [double width]) &#123; _draw(config, canvas, points, true, width); return this; &#125; /// 画区域 HeatLineMonet paintArea( PaintConfig config, Canvas canvas, List&lt;Point&gt; points) &#123; _draw(config, canvas, points, false); return this; &#125; /// 通过上次的路径裁切画布 HeatLineMonet clipPreviousPath(Canvas canvas) &#123; canvas.clipPath(_path); return this; &#125; _draw(PaintConfig config, Canvas canvas, List&lt;Point&gt; points, bool drawLine, [double width]) &#123; Paint p = Paint(); width == null ? p.strokeWidth : p.strokeWidth = width; p.style = drawLine ? PaintingStyle.stroke : PaintingStyle.fill; p.shader = config.shader; config?.color == null ? p.color : p.color = config.color; _path = _getPath(points, config?.smooth, config.bottomToTop, !drawLine); canvas.drawPath(_path, p); if (config.keyPointsVisible) &#123; var offsets = List&lt;Offset&gt;(); p.strokeWidth = 3; points .forEach((p) =&gt; offsets.add(Offset(p.x.toDouble(), p.y.toDouble()))); canvas.drawPoints(PointMode.points, offsets, p); &#125; &#125; Path _getPath( List&lt;Point&gt; points, bool smooth, bool bottomToTop, bool circle) &#123; double minY, maxY; points?.forEach((p) &#123; minY = minY == null ? p.y.toDouble() : min(minY, p.y.toDouble()); maxY = maxY == null ? p.y.toDouble() : max(maxY, p.y.toDouble()); &#125;); final path = Path() ..moveTo(points.first.x.toDouble(), points.first.y.toDouble()); smooth ? CubicBezierMonet.addCurve(path, points) : points.forEach((p) =&gt; path.lineTo(p.x.toDouble(), p.y.toDouble())); circle ? path.lineTo(points.last.x.toDouble(), bottomToTop ? maxY : minY) : path.getBounds(); return path; &#125;&#125; 搞定 PS 这里只列举出比较关键的代码，不是全部]]></content>
      <categories>
        <category>Flutter</category>
      </categories>
      <tags>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向Java开发者的Dart使用建议]]></title>
    <url>%2Fblog%2Fdart-advice-for-java-developers%2F</url>
    <content type="text"><![CDATA[Flutter 发展的如火如荼，越来越多的开发者开始使用，Dart 作为它的编程语言，借鉴了很多 Java 的特性，并针对其被人诟病的地方做了大量的优化，以下列出一些针对 Java 开发者的 Dart 使用建议，包括书写思想、特殊语法等 面向对象Dart 中的面向对象更加彻底 null 、操作符、方法 都是对象 privateDart 中没有 public private 关键字，私有通过标识符以下划线开头来表示 var dynamicDart中可以不指定变量类型，或指定为动态类型 操作符操作符是对象，也可以被重载 字符串插值器多使用字符串插值器，${expression} $var，少用 Java 中使用加号连接的方式 方法是对象灵活使用方法，方法可以赋值给变量，可以当作方法的参数 更优雅的重载Dart 中的方法重载于 Java 不同，个人更喜欢 Dart 的实现方式 可选位置参数 123String say(String name, [String message, String device]) &#123; /// ...&#125; 可选命名参数 123updateProfileData(String nickName, &#123;String avatar, int age&#125;) &#123; /// ...&#125; is 与 is!Dart 中有 is! 操作符，不需要 !(object is String) 这种方式 级联操作符 .. 在同一个对象上连续调用多个函数以及访问成员变量 避免创建临时变量，代码整洁流畅 严格来说，不是操作符，可以理解成Dart的语法糖 1234final Paint bgPaint = Paint() ..color = circleBgColor ..strokeWidth = strokeWidth ..style = PaintingStyle.stroke; 条件成员访问操作符 ?. 和访问成员类似，但左面表达式为空则不执行后面的表达式，如foo?.bar，如果foo为空则返回空，否则返回bar成员 减少了大量的判空代码 非空操作符??前面的表达式非空时才执行后面的表达式 空赋值操作符??=指定值为 null 的变量的值 断言 Assert 如果条件表达式结果不满足需要，可以使用assert语句打断代码的执行 断言只在检查模式下运行有效 生产模式下，断言不会执行 断言检查失败，会抛出一个AssertionError异常 多用！ new关键字可省略异步支持 Dart 是基于事件循环机制的单线程模型编程语言 有一些语言特性来支持异步，最常见的是 async 和 await “Dart是单线程的”与“Dart支持异步”是不矛盾的 返回 Future 和 Stream 对象的方法 踩坑 请牢记，await、await for 表达式需要确保使用它的方法被 async 包裹！ 不管有多少层调用，只要有一层没 async，后调用的就可能出现问题！ 因为构造方法不能被 async，所以避免在构造方法中使用 await！ Effective Dart 类命名使用大驼峰，库、导入前缀和文件命名使用小写加下划线，常量使用小驼峰 要使用编译器格式化或 dartfmt 命令格式化代码 要使用 /// 文档注释来为成员和类型增加注释 定义字符串推荐多使用相邻字面量和插值器的方式，避免使用多余的大括号 要尽可能的使用集合字面量来定义集合 推荐使用 final 关键字来限定只读性 推荐使用箭头来实现只有一个单一返回语句的函数 不建议显示捕获 Error 及其子类 推荐使用 await async 完成异步，而不是使用底层的特性 不要在没有作用效果的情况下使用 async 要使用 getter 来定义访问属性的操作 避免在不必要的地方使用 dynamic 类型 要在复写 == 的同时复写 hashCode 踩坑记录 不要在 Iterable.forEach() 中使用函数声明形式 如果想完成异步，包含 await 表达式的函数，包括间接调用的，都需要加上 async 标记 不要在 Iterable.forEach() 中使用 await 语句 不要在构造函数与内使用 await 语句 个人建议 多看源码 学习 发现便捷的函数 list.isEmpty() 与 list.isNotEmpty() 理解面向对象 操作符 方法 多使用提供的语法糖，体验灵活性 ??= ?? .. ?. getter setter 方法的可选参数 不影响阅读的前提下，尽可能简化代码 私有方法，方法返回类型不需要声明 适合一个编译器窗口，左右同时打开两个文件写代码 不要把类和文件当作一个维度]]></content>
      <categories>
        <category>Language</category>
      </categories>
      <tags>
        <tag>Dart</tag>
        <tag>Flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Submodule 使用笔记]]></title>
    <url>%2Fblog%2Fgit-submodule-note%2F</url>
    <content type="text"><![CDATA[在学习和工作中，经常会遇到一个Git仓库中要引入另一个Git仓库，或者工程中的一部分代码在单独的Git仓库管理更清晰的情况，如： 整个博客工程对应了一个Git仓库，但展示需要的只是其中一部分，部署在一个单独的Git仓库更合适 实际工作中负责新闻客户端的开发，需要本地集成前端模板，由前端同学维护，是一个独立的Git仓库 遇到这种情况，使用submodule(子模块)的方式集成到主工程中较好。因为平时用得不多，命令总记不住，所以写个博客记录下～ 0. 相关资源 git submodule --help Git子模块 官方文档 1. 添加子模块1git submodule add $&#123;submoduleRepositoryUrl&#125; 运行后会将添加的子模块仓库clone到工程中，完成后会自动出现.gitmodules配置文件，格式如下 2. 更新子模块`方式1 直接在主工程下更新子模块1git submodule update --remote $&#123;submoduleName&#125; 方式2 在子模块工程下更新自己12cd $&#123;submoduleName&#125;git pull #(or fetch + rebase ...) 3. 移除子模块方式1 直接在主工程操作12git rm -f $&#123;submoduleName&#125;git rm -f --cached $&#123;submoduleName&#125; #在本地保留 方式2 在配置文件中删除+操作文件12vi .gitmodulesvi .git/config 4. 克隆含有子模块的工程方式1 递归克隆1git clone --recursive $&#123;repositoryUrl&#125; 方式2 克隆主工程后再拉取子模块123git clone $&#123;repositoryUrl&#125;git submodule initgit submodule update]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell脚本笔记]]></title>
    <url>%2Fblog%2Fshell-programming-note%2F</url>
    <content type="text"><![CDATA[现在算是一个shell编程入了门的小菜鸟，本文是把学习、开发过程中遇到的一些常见的/有用的 语法/命令记录下来 Shell命令篇 一些常见的就不列举出来了，如ls cd等 dig 域名解析命令，可以看到域名状态、重定向等信息 1dig www.mrliuxia.com man 命令介绍手册，不过一些后安装的、非系统自带的命令不一定有，原理是要往系统的一个目录下写入类似于windows chm格式的说明文档 which 查找文件，会在环境变量$PATH设置的目录里查找符合条件的文件 常用于查看指令的绝对路径 Shell编程语法篇while循环1234while 条件do ...done for循环1234# 将输入的所有参数组合起来for args in $* ; do title=$&#123;title&#125;$&#123;args&#125;done 写入文件1234# 覆盖写入echo "$&#123;content&#125;" &gt; $&#123;filePath&#125;# 追加写入echo "$&#123;content&#125;" &gt;&gt; $&#123;filePath&#125; 整数相关自加123456789101112# 相加，4种方法，萝卜白菜let a=$1+$2b=$[$1+$2]((c=$1+$2))d=`expr $1 + $2`# 自加1，6种方法a=$(($a+1))a=$[$a+1]a=`expr $a + 1`let a++let a+=1((a++)) 比较123456789101112131415# 等于if [[ "$a" -eq "$b" ]]...# 不等于if [[ "$a" -ne "$b" ]]...# 大于if [[] "$a" -gt "$b" ]]...# 大于等于if [[ "$a" -ge "$b" ]]...# 小于if [[ "$a" -lt "$b" ]]...# 小于等于if [[ "$a" -le "$b" ]]...# 也可以使用用符号，如if [[ $&#123;a&#125;==$&#123;b&#125; ]]...if (("$a" != "$b"))... 输入是否是整数123456## 记录一种简单的方式if [[ "$1" -gt 0 ]] 2&gt;/dev/null ;then echo "$1 is number." else echo 'no.' fi 字符串相关比较字符串123# 是否相等if [[ "$a" = "$b" ]]...if [[ "$a" == "$b" ]]... 是否为空12if [[ -z "$a" ]]...if [[ -n "$a" ]]... 反转字符串12345678# 判断是否是回文function palindromic()&#123; if [[ !(-z "$1") &amp;&amp; $(rev &lt;&lt;&lt; "$1") == "$1" ]]; then echo yes else echo no fi&#125; 过滤字符串12# 将第一个参数过滤掉","echo $1 | grep -v "," 截取字符串1234# 从第1个字符开始，截取a的两个字符echo $&#123;str:1:2&#125;# 截取最后两位echo $str | sed 's//(.*/)/(../)$//' IFS INIT_PATH脚本常见开头判断参数个数12345# 若参数个数小于2则报错if [[ $# -lt 2 ]]; then echo -e "\033[31mError: need 2 args.\033[0m" exit 2fi 获取输入参数12345678910# 获取-t -i参数while getopts "t:p:g:c:i:" cmddo case $&#123;cmd&#125; in t) title=$&#123;OPTARG&#125;;; i) id=$&#123;OPTARG&#125;;; esacdone 按行读文件1234567# 按行读文件并输出cat $0 | while read lineNodo echo "$lineNo"done# 使用awkcat $0 | awk 'for(i=2;i&lt;NF;i++) &#123;printf $i&#125; printf "\n"&#125;' 附录1. 一元操作符 指令 含义 -e 文件存在 -a 文件存在（已被弃用） -f 被测文件是一个regular文件（正常文件，非目录或设备） -s 文件长度不为0 -d 被测对象是目录 -b 被测对象是块设备 -c 被测对象是字符设备 -p 被测对象是管道 -h 被测文件是符号连接 -L 被测文件是符号连接 -S(大写) 被测文件是一个socket -t 关联到一个终端设备的文件描述符。用来检测脚本的stdin[-t0]或[-t1]是一个终端 -r 文件具有读权限，针对运行脚本的用户 -w 文件具有写权限，针对运行脚本的用户 -x 文件具有执行权限，针对运行脚本的用户 -u set-user-id(suid)标志到文件，即普通用户可以使用的root权限文件，通过chmod +s file实 -k 设置粘贴位 -O 运行脚本的用户是文件的所有者 -G 文件的group-id和运行脚本的用户相同 -N 从文件最后被阅读到现在，是否被修改 2. 二元操作符 指令 含义 -eq 等于 -ne 不等于 -gt 大于 -ge 大于等于 -lt 小于 -le 小于等于 注释: shell中也支持&gt; &gt;= &lt; &lt;= = == !=操作符，其中=和==含义相同]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>编程语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac使用笔记]]></title>
    <url>%2Fblog%2Fuse-mac-notes%2F</url>
    <content type="text"><![CDATA[此文的目的是记录下在使用macOS过程中个人觉得还不错的习惯、还不错的软件，帮助大家喜欢上使用Mac…… 更新中…… 文内图片找回中，七牛真坑，图片原外链不让访问，还不让下载 个人观点： macOS在易用性上完爆Windows，Windows只适合用来娱乐和一些必须要用一些不支持macOS或支持得不好的软件的场景（本人使用到的98%的软件都有mac版本，或者有可替代的软件，甚至只有mac版本） 尤其是开发同学，强烈建议使用Mac，个人从Windows转移到Mac并熟悉了系统之后，开发效率提高了至少一倍 个人建议千万不要做双系统，非要用Windows系统还不如再买个Windows电脑 还不错的习惯 多用快捷键，mac的快捷键设计的很合理，不像臭名昭著的win键 Command键用左手大拇指按 使用caps lock（大小写锁定）键来切换中英文 把系统设置里所有东西都过一遍，设置触发脚，显示桌面/进入屏保，很方便 多用Spotlight，很方便，比如 打开应用（建议输入英文名因为快） 文档搜索 直接输入算式以计算 汇率计算（输入：1美元） 单词翻译 如果用的是Mac笔记本/有触控板的话，尽量不要用鼠标 还不错的软件常用软件 因为这个类别没什么技术含量，基本上所有用mac的人都会用，所以不详细说明，只是列举出来 微信、网易云音乐、Chrome、网易邮箱大师、Thunder、百度网盘、腾讯视频等 文本软件 Office三件套有mac版本，但是用起来觉得一般般，总是卡顿，很少用 Mac办公三件套（Page、Keynote、Numbers）用起来很舒服，且很容易上手，也能导出为office的格式，推荐使用 Markdown编辑器： Typora 个人很钟爱用markdown格式写文本，因为可以通过使用简单符号的方式快速排版，这样可以让自己专注在写作上，而不是用在排版这种浪费时间的事情上（对于记录这个行为来说），个人也很建议平时写文档使用markdown格式来记录 关于markdown的介绍可以看这里： 维基百科：Markdown Github中star数最高的Markdown介绍 简书：Markdown新手指南 本人使用过很多Markdown编辑器，多数设计的风格是编辑区和渲染效果区左右分开， 当发现Typora这个软件之后内心的想法是： 卧槽真特么好用，只有正在输入的地方显示编辑效果，其它地方显示的是渲染效果 卧槽界面真舒服，浓浓的性冷淡风，还支持很多渲染主题 卧槽真特么良心，各种格式几乎都有快捷键，所有markdown语法还都支持，还支持中文 卧槽这软件做的这么好还是免费的 Typora官网及下载链接 笔记工具： 有道云笔记本人也使用过很多笔记软件做过横向对比，比如常见的印象笔记、为知笔记、OneNote，也用过小众的Leanote，在综合考虑以下几个方面的原因后，最终选择了有道云笔记+系统自带Notes+个人网站 同步功能 Markdown支持 操作舒适度及界面风格 免费版功能已足够日常使用 官网及下载链接 计划软件 本人对于这类软件要求不是很高，正在使用的是前两个 Reminders + Calendar系统自带的两个应用，个人觉得已经满足大部分人的需求，界面还算友好，操作不算复杂，重点是在mac和手机上同步得很快 Clear操作、界面都很简洁，能够满足平时需要，但是缺点是不能看历史记录 ps 需付费 AppStore 链接 Omni系列应对较复杂的场景，自己用过一次放弃了，不需要这么复杂 AppStore 链接 工具软件剪贴板 - Paste强烈推荐，用着巨舒服，Command+Shift+v会显示剪贴板历史，且几乎支持所有格式 AppStore 链接 截图工具 - Snipaste微软出品的良心软件，功能比同类软件强大很多，且操作也很舒服，和Paste配合起来天衣无缝 ps1 之前用过腾讯的Jietu、Xnip等始终不满意，发现Snipaste之后简直破费，使用方便、功能全、UI舒服 ps2 建议在使用这个软件的时候把其他应用自带的截图工具快捷键取消掉 Snipaste官网及下载 图床工具 - iPic / PicU作为一个以markdown为最常用书写方式的人，图床工具是很必要的（因为markdown插入图片的方式是插入图片的链接），一键上传，一键复制为markdown格式，美滋滋，妥妥的生产力 发现了两个图床工具都很好用，iPic免费版只支持微博图床，PicU是一个开发者模仿iPic开发的工具，很强 iPic AppStore链接 PicU Github地址 PicU 简书介绍地址 清理工具 - CleanMyMac3虽然说mac正常情况下不需要清理，如果实在是磁盘没地方的话清理下也不错，CleanMyMac是很有名的老牌清理工具，能发现这么老多系统垃圾我也是很震惊 CleanMyMac官网及下载 ### 编程软件编译器 - Jetbrains公司全系列产品在用过CodeBlocks、Netbeans、Eclipse等很多个编译器，在接触到Jetbrains公司的编译器产品后发现真特么舒服，再也不会换编译器了，优点大概是 强大、迅速、友好等等该有的随便吹 各种语言都有对应的产品，还有数据库、持续集成等的产品 快捷键很多很舒服（一定要多用快捷键） 插件很多质量很高，自己写也较简单 Jetbrains官网 Java编译器 - IDEA Python编译器 - PyCharm C编译器 - CLion Web编译器 - WebStorm 激活方式：（毕竟几千块还是有点贵……） 自行搜索，有大神的激活教程 学生可以进行学生认证，学生认证后免费使用 API文档工具 - Dash支持的语言很丰富，各种语言的API文档 Dash官网及下载 抓包工具 - Charles功能巨强大，前端客户端开发必备 Charles官网及下载 ####]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用AS新建工程preDebugAndroidTestBuild报错]]></title>
    <url>%2Fblog%2Fandroid-studio-new-project-build-failed-preDebugAndroidTestBuild%2F</url>
    <content type="text"><![CDATA[使用Android Studio 3.0新建工程，一路默认走下来竟然报错了，报错内容： 12Error:Execution failed for task &apos;:app:preDebugAndroidTestBuild&apos;.&gt; Conflict with dependency &apos;com.android.support:support-annotations&apos; in project &apos;:app&apos;. Resolved versions for app (26.1.0) and test app (27.1.1) differ. See https://d.android.com/r/tools/test-apk-dependency-conflicts.html for details. 文内图片找回中，七牛真坑，图片原外链不让访问，还不让下载 原因排查 吐槽：讲道理，怎么编译器新建一个默认工程还能报错啊，好吧，解决它 看报错信息，是com.android.support:support-annotations这个包引入了两个版本，看编译后的环境，确实如此 默认的build.gradle dependencies标签下是这样的 12345678dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.1.0' implementation 'com.android.support.constraint:constraint-layout:1.1.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'&#125; 排查后发现，&#39;com.android.support:appcompat-v7:26.1.0&#39;这里包含的是26.1.0版本的annotations包，而&#39;com.android.support.test:runner:1.0.2&#39;和&#39;com.android.support.test.espresso:espresso-core:3.0.2&#39;这两个用于测试的库包含27.1.1版本 解决问题方式1如果需要用runner和espresso这两个用于测试的库，可以直接把这两行去掉，gralde文件变成： 123456dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.1.0' implementation 'com.android.support.constraint:constraint-layout:1.1.2' testImplementation 'junit:junit:4.12'&#125; 方式2声明runner和espress两个测试库不重复引入annotations包 12345678910111213dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar'])Ω implementation 'com.android.support:appcompat-v7:26.1.0' implementation 'com.android.support.constraint:constraint-layout:1.1.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2', &#123; exclude module: 'junit' exclude group: 'com.android.support', module: 'support-annotations' &#125; androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2', &#123; exclude group: 'com.android.support', module: 'support-annotations' &#125;&#125; 方式3强制声明最终引入的annotations包的版本 12345678910111213dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar'])Ω implementation 'com.android.support:appcompat-v7:26.1.0' implementation 'com.android.support.constraint:constraint-layout:1.1.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2' androidTestImplementation('com.android.support:support-annotations:26.1.0') &#123; force = true &#125;&#125; 大吉大利好了终于正常了，大吉大利]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
        <tag>Android Studio</tag>
        <tag>AS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【不懂就记】Gradle implementation、api命令]]></title>
    <url>%2Fblog%2Fandroid-gradle-implentation-api%2F</url>
    <content type="text"><![CDATA[发现Android Studio升级到3.0版本以后，新建工程默认的app包的build.gradle文件有点不认识了，长成这样，主要是implemention这个命令是什么鬼 12345678dependencies &#123; implementation fileTree(dir: 'libs', include: ['*.jar']) implementation 'com.android.support:appcompat-v7:26.1.0' implementation 'com.android.support.constraint:constraint-layout:1.1.2' testImplementation 'junit:junit:4.12' androidTestImplementation 'com.android.support.test:runner:1.0.2' androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'&#125; 背景Android Studio再升级到3.0版本后，gradle插件版本默认升级到了3.0.0版本，在此版本中不推荐使用gradle的compile命令，推荐使用implemention命令和api命令 文档资源 强推: Google I/O 2017 - Speeding Up Your Android Gradle Builds演讲关于Implemention和API的部分 Implementation vs API dependency (大概是把I/O演讲的整理记录了下) 记录的中文翻译版本 谷歌官方迁移(升级)到Android Plugin for Gradle3.0文档 Implemention和API命令的使用 在I/O 2017的演讲中，演讲者将build一个工程比作是pay taxes，给人的感觉确实也是如此，构建工程的速度很重要，立个flag，过段时间整体研究下 api命令和原来的compile命令完全相同 implemention命令对于使用了该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开 例子1. 使用compile/api12A compile BB compile C 那么A是可以直接调用C的方法的 2. 使用implemention12A implemention BB implemention C C的内部方法对B可见，对A不可见，即A不能直接调用C的方法 好处：在C源码发生变化的时候，只重新编译直接引用C的module(B)，A不重新编译，提高工程构建速度]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在命令行(Terminal)中自动生成二维码]]></title>
    <url>%2Fblog%2Fgenerate-qr-code-in-terminal%2F</url>
    <content type="text"><![CDATA[shell小白，此脚本实现的功能是在命令行中自动生成输入的文字/链接的二维码 相关资源 brew: 或许是mac上安装软件最方便的方式？ https://brew.sh/ qrencode: “a fast and compact QR Code encoding library” https://github.com/fukuchi/libqrencode 实现思路 检测brew环境，若没有，则安装 检测qrencode环境，活没有，则安装 使用qrencode生成二维码，并打印 123456789101112131415161718192021222324252627282930313233343536#!/usr/bin/env bash#若没有brew环境，安装brewif which brew &gt; /dev/null ; then echo "brew has been installed."else echo "brew not installed, install brew first." ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"fi#若没有qrencode库，安装qrencodeif which qrencode &gt; /dev/null ; then echo "qrencode has been installed."else echo "qrencode not installed, install brew first" brew install qrencodefi#处理参数，获取要生成二维码的信息if [ $# == 0 ]; then read -p "Enter message here: " messageelif [[ $1 == "help" ]] || [[ $1 == "--help" ]]; then echo "A tool for generating qr code." echo "Example usage:" echo " qrcode \"http://www.163.com\"" echo " qrcode \"n 55!W\"" echo "Further help:" echo " qrcode help" echo " qrcode --help" exitelif [ $1 ]; then message=$1fi#打印二维码echo $message | qrencode -o - -t UTF8 运行效果]]></content>
      <categories>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>QR Code</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google I/O 2018 - (一) Keynote]]></title>
    <url>%2Fblog%2Fgoogle-io-2018-1-keynote%2F</url>
    <content type="text"><![CDATA[2018年Google I/O大会5月8日–5月10日美国加利福尼亚州芒廷维尤海岸线圆形剧场举行，这一系列文章是观看视频录像的笔记，此文为第一部分，Keynote 文内图片找回中，七牛真坑，图片原外链不让访问，还不让下载 Google I/O 2018 - KeynoteI/O大会官网：https://events.google.com/io 视频链接：https://www.youtube.com/watch?time_continue=441&amp;v=ogfYd705cRs 1. AI1.1 一些应用场景 语音拆分（7:24） 语音生成（摩尔斯电码） 邮件 输入联想 摄像 一些图像识别 1.2 Google Assistant &amp; Google Duplex Holy -&gt; Siri?（”Hey Google”） 然而。。尴尬的事情。。 Continued conversation、Google Assistant其他使用场景 1.3 Naturally conversation New voices Continued conversation Multiple actions Pretty please Google Assistant 打电话订理发、订饭店 Google duplex 亮点，根本听不出来是机器人(36:30) 1.3 Digital Wellbeing Youtube，看了多久提示该休息了，notification整合 2. Google News2.1 Keep up with news you care about Newscast 2.2 Understand the full story full coverage (专题)（更全面事件的发展 local coverage, time line ） 2.3 Enjoy and support the news sources you love Newsstand(杂志摊) Subscribe with Google -&gt; search we’re rolling out on Android iOS and the web in a hundred and twenty seven countries starting today 3. Android P Android started with a simple goal of bringing open standards to the mobile industry 宣传了一波“OPEN” 开放性 10年 3.1 Android P的三个主题 Intelligence Simplicity Digital wellbeing 3.2 Intelligence3.2.1 Adaptive Battery 3.2.2 Adaptive Brightness 3.2.3 App Actions &amp; Slice 预测下一个应用 -&gt; 预测下一个行为 搜索、语音、应用商店 Slice: app提供一些内容给其他app调用，如搜索结果(spotlight) 3.2.4 ML Kit cross-platfrom Android &amp; iOS 3.3 Simplicity 功能键的衍变 手势+小方块（iPhone X）、旋转等 3.4 Digital wellbeing3.4.1 Dashboard App usage notification 3.4.2 App Timer3.4.3 Do Not Disturb -&gt; Shush Starred Contacts 3.4.4 Wind Down Mode屏幕变灰，帮助睡前少玩手机 3.5 Android P Beta 4. Google Maps 谷歌地图变得更加社交化 match cooperation with carema 增强现实 4.1 GPS -&gt; VPS(Visual Positioning System)4.2 Google Lens4.2.1 Smart text selection 4.2.2 Sytle match 4.2.3 Real-time results 5. Self-driving Cars（WAYMO） 这老哥生活应该挺丰富多彩…… back in those early days Google was perhaps the only company in the world investing in both AI and self-driving technology at the same time 5.1 Perception5.2 Behavior prediction5.3 Decision-making5.4 Mapping]]></content>
      <categories>
        <category>Sight</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Sight</tag>
        <tag>Google I/O 2018</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android历史版本]]></title>
    <url>%2Fblog%2Fandroid-api-history-version%2F</url>
    <content type="text"><![CDATA[Android历史版本信息，code name &amp; version &amp; API level &amp; release date 参考来源 谷歌开发者官网：SDK Platform release notes Code name Version API level Release date — 1.0 1 2008.09.23 Petit Four 1.1 2 2009.02.09 Cupcake 1.5 3 2009.04.27 Donut 1.6 4 2009.09.15 Éclair 2.0-2.1 5-7 2009.10.26 Froyo 2.2 8 2010.05.20 Gingerbread 2.3 9 2010.12.6 Honeycomb 3.0-3.2 11-13 2011.02.22 Ice Cream Sandwich 4.0 14-15 2011.10.18 Jelly Bean 4.1-4.3 16-18 2012.07.09 KitKat 4.4 19-20 2012.10.31 Lollipop 5.0-5.1 21-22 2014.12.12 Marshmallow 6.0 23 2015.10.05 Nougat 7.0-7.1 24-25 2016.08.22 Oreo 8.0 26 2017.08.21 8.1 27 2017.12 Pie 9 28 2018.08.07]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git将修改提交到已经commit的n次提交之前]]></title>
    <url>%2Fblog%2Fgit-commit-to-swh%2F</url>
    <content type="text"><![CDATA[在使用git的过程中，遇到了想把新的修改添加到之前的提交中的情况。如果想追加到最后一次提交，那很好办，直接git commit --amend就可以；如果想提交到之前的某次提交，那就有点麻烦了 想法1: 使用stash （❌）1.1 实现步骤： 依次将倒序过去的每次提交git reset --soft后用stash存起来 将要追加的修改commit —amend添加进去 依次将每个stash pop应用出来 1.2 遇到的问题： 使用stash保存，发现apply的时候需要重新commit，达不到好的自动化效果 reset的时候需要将每次commit的信息保存好，再次commit的时候使用，麻烦 想法2: 使用patch+stash （✅）2.1 实现步骤： 将现有修改stash贮存 将距离目标commit中间的若干提交生成patch 将仓库reset --hard到目标commit 应用stash，追加到目标commit 将patch恢复，删除缓存patch文件 2.1 具体实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#!/usr/bin/env bash### 参数为倒数第n次提交### 判断参数是否合法if [ $# == 0 ] ;then echo "there should be an args" exitfiif [ $1 == "help" ] ;then echo "将现有修改提交到n次提交之前" echo "比如commit1&lt;-commit2&lt;-commit3,提交到commit1,则参数为2" exitfiif [ $1 -gt 0 ] 2&gt;/dev/null ;then echo "git add to commit HEAD~$a"else echo "$1 should be a number" exitfi# 正题n=$1# 将现有修改添加到stashgit add .git stash# 将中间n次提交打patchgit format-patch HEAD~$n --numbered-files -o ~/patchtemp# 将git强制reset到n次提交之前git reset --hard HEAD~$n# 将stash应用,并添加到目标提交git stash apply stash@&#123;0&#125;git add .git commit --amend# 将各个patch恢复declare -i i=1while((i&lt;=$n))do git am -s &lt; ~/patchtemp/$i let ++idone# 删除patchrm -r ~/patchtemp]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何给博文加密]]></title>
    <url>%2Fblog%2Fhexo-encrypt-blog%2F</url>
    <content type="text"><![CDATA[博客当然也要有记录生活的功能，怎么能放心的记(tu)录(cao)生活而不担心被陌生人看到呢，那就需要对博文进行加密了。本文介绍了使用hexo-blog-encrypt插件完成对博文进行加密的方式，可以放心的写一些羞羞的事情了~ 通过hexo-blog-encrypt插件实现，插件github地址：https://github.com/MikeCoder/hexo-blog-encrypt ，上面有使用方式的介绍 1. 安装encrypt插件在hexo根目录下的package.json中dependencies标签下添加： 1"hexo-blog-encrypt": "2.0.*" 更新环境安装插件 1$ npm install 2. 在配置文件中启用插件在站点配置文件 _config.yml中启用插件，添加如下配置 1234# Security## Docs: https://github.com/MikeCoder/hexo-blog-encryptencrypt: enable: true 3. 使用encrypt插件加密文章在文章头中添加password字段 123456---title: hello worldpassword: liushaoxiaabstract: 加密文章的简介message: 输入密码上方的提示--- 4. live demodemo: 博文加密测试 , 密码是liushaox 5. 高阶使用方式可以对文章目录TOC进行加密、修改加密模板，具体方式转步插件作者wiki查看： github：https://github.com/MikeCoder/hexo-blog-encrypt/ 中文版：https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博文加密测试]]></title>
    <url>%2Fblog%2Fhexo-encrypt-blog-example%2F</url>
    <content type="text"><![CDATA[下面输入密码, 错了就打不开哈哈哈哈 U2FsdGVkX1+ZvWKcqeKUPRLO8A62UHhnSbfC3A6uwmWibPNLZ9nQiG7mS3Zj982msi+3UXHrxRUbUE2zcjA4Ksu4hH/v85hHLm5UJbnPgtxsgFhbXES5QFwl1/NebANuURr3sJg/c6VYrZP3D0ahUYL2/ymaQahMP0XIjxETa4I5NbKVoCWu3mXL3EZ5zIJdWY8TQ+/y3H6oD+jlxM2kX4UrvZoaAhRySZuAGhZHF7wXD4A2oRhcOp7OgeA5Aa+MPkYUmophyWglgW8YH9ghX2/G4Q8rl6LPn41qHV7E6GoZESvGr+20+KVJxaNrECvXE0ozmnWuzQ1RkCsexVKXyRicsdUftOFrsOVa5WLePKuftNXyXuikIGhktknKbjCOHfnVu0T4RKfCyuTIdOH6roKLKVAzw7flCEYva/l8isqwT6bgHE7bly3DSjbpe3Q+Bom/RF+qREAGT1kgec/43lITajoh3AUHracOu6OQXzjxqLANAsyA/wnLXXbJ7eqi6Fx53BT9l8z0gcLWOz/YaKwWUn5MyHu2k8qKwzc6H+iJ+Q2ArNMCBNxr1WbgqUO0ZW0tzyGGarh134O1SaoWXCqCGFB5f0BrT7xFMx24l1X9o2Aie1Zinx65w7IcL4z9oY8iw4jg84pg7k9I2XOWj5oc0PS+TMBM/sGp1rmUIC6THGFlAli1nT9nkG2doR86rud61TkQEL+aEJOkH7mbu/7Qle+ZpHVIvsVi48cK1ph0Bpvt4wQHsucp+/EmD13PL2EdU29NEIlz//XekjXhOZO89c670nciU9pf6OdHYZo5QG8DsnQfqJuQ0mUkmAE523D9RyZ5zjsgj/W64G1SEnK76tQS6oXlJoU2KT2MQq/t1GFIpWeK+LWC5jr5YydawEZtsDXHa9mfqhh48oLkrgquTb9Tg/1imd3UP0o3RMe9PtnskyruohML+k8+2qSAAUQmQm849A9yEBEVkpDEsVeMgsWFQn4bWc8J85Wc3nkeURugbdhZO+0s8ZmBJesy0ezX05rWg6KqGlOTzU4sdCgf4MJnt+ERC7OcyhIkgfhY3oGOoFmxAzunXtncTGdVCBDtX0ArKJa8X/s6XHX4HXROs0mBist0zjZvO4CGxkU3i3p9jOG8Ux3NmsESHX+DdTmoLL7ySrU0rt8kBTWZX+ZwiCDkRmhpvz7RoUbm7mk=]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用进阶命令使用笔记]]></title>
    <url>%2Fblog%2Fgit-advanced-command-note%2F</url>
    <content type="text"><![CDATA[本文记录了使用git过程中常用的命令，因git基础命令多数人都知道，所以把常用的进阶命令写在前面，也当作是自己的笔记。文章中间有几个使用git遇到的小问题，还挺有意思，给出我的解决方案作为参考～ 建议多查官网 https://git-scm.com/bookhttps://git-scm.com/book/zh/v2 常用进阶命令1. 修改仓库/分支信息12git remote set-url origin https://xxx.git #修改整个仓库的远程位置git branch --set-upstream-to=origin/master #修改当前分支关联的远程分支 2. 修改提交信息(commit message)12git commit --amend #修改上一次提交的commit messagegit rebase -i HEAD~n #修改上n次提交的commit message（也可以用来删除某次提交） 3. 将修改追加到上次到提交12git add . git commit --ammend #多用途 4. 撤销add12git reset HEAD #全部撤销git reset HEAD your_file_path #撤销单个文件 5. 查看git信息123456git config --list #查看git整体配置信息列表git remote -v #查看远程仓库地址git branch -v #查看本地分支&amp;基本信息git branch -vv #比上条多了关联的远程分支（pull/fetch的分支）git branch -r #查看所有远程分支git branch -a #查看所有分支 6. stash123456git stashgit stash save "message" #将stash命名为messagegit stash save -a "message" #将git忽略的文件也stash，不常用git stash list #stash列表git stash pop #将stash第0条应用并删除git stash apply stash@&#123;2&#125; #将index=2的stash应用 7. patch1234567git format-patch HEAD^ #HEAD的patchgit format-patch HEAD^^ #HEAD和前一个的patchgit format-patch HEAD~$n -o ~/patchdir #将前n次提交打patch，保存到～/patchdir目录下git format-patch HEAD~$n --numbered-files #将前n次提交打patch，文件名保存为数字git apply --stat xxx.patch #检查patchgit apply --check xxx.patch #查看是否能应用成功git am -s &lt; xxx.patch #应用patch 8. 创建新分支12git checkout -b feature/dev_liuxiaogit checkout -b feature/dev_liuxiao --track origin/master #基于远程跟踪分支master创建本地分支 -b 参数的意义是什么？ 创建分支，若本地无此分支，会报错 9. pull/fetch/push12345678910111213141516171819202122#1. pullgit pull origin master:dev #拉取远程master分支，和本地dev分支合并git pull --rabase origin master:dev #拉取远程master分支，和本地dev分支使用rebase的方式合并#如果本地和远程分支之间存在追踪关系（tracking），可以省略分支名git pull origingit branch --set-upstream dev origin/master #将本地dev分支建立远程追踪分支为origin/master#2. fetch #pull相当于fetch+mergegit fetch origin #拉取远程更新git merge origin/master #将远程更新合并到本地当前分支#3. push#-ugit push -u origin dev #将本地dev分支push到远端#-u 相当于 没有参数+upstreamgit branch --set-upstream dev origin/mastergit push origin dev#-fgit push -f origin dev #将本地dev分支强行push到远端，冲突强行覆盖（保护的分支需要权限）#如果本地分支名和远程目标分支名不同git push origin HEAD:master -u 参数的意义是什么？ 在push的同时，设置了远程关联分支 git push -u origin feature/webView相当于git push origin feature/webView; git branch —set-upstream-to=origin/feature/webView feature/webView 10. 删除123git clean -f #删除untracked filesgit clean -f -n #查看会删除的filesgit clean -f -d #删除untracked文件夹 11. log12git reflog #历史记录 #可以拿到已经回滚reset过的提交的id，通过git reset id，可以把回滚过的提交找回 可思考/研究的常见问题1. 如何删除一个远程分支？12345#方式1. git UI操作，通常在setting/branches中#方式2. 将一个空目录提交到制定远程git push origin:dev#方式3. delete参数git push origin -delete dev 2. 如何将修改追加到已经push了的n次提交之前？基础1. 安装git环境1sudo apt-get install git-core #windows在官网下载环境 2. 创建代码仓库 配置身份 12git config --global user.name "liushaox"git config --global user.email "liushaox@163.com" 查看身份 12git config --global user.namegit config --global user.email 初始化为git文件夹 1git init 3. 提交本地代码1234git add AndroidMainfest.xml #添加单个文件git add src #添加单个文件夹git add . #添加所有文件git commit -m "first commit" #添加提交描述信息 4. 状态相关123git status #查看git状态，包括commit、修改、冲突等git diff #查看更改内容git diff app/src/main/java/activity/MainActivity.java #查看单个文件更改内容 5. 常见操作流程123456789101112# clonegit clone https://xxx.git# 第一次上传git initgit add . git commit -m "commit message"git remote add origin https://xxx.gitgit push -u origin master# 以后上传git add . git commit -m "commit message"git push -u origin master]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
